name: kube cert refresh
description: Action to refresh cert and push into kubectl
inputs:
  cert:
    description: cert name
    required: true
  jwt:
    description: jwt with access to the cert api
    required: true
  group:
    description: Owning team
    required: true
  context:
    description: kubectl context to use
    required: true
  namespace:
    description: csv list of kubernetes namespace's the secret should exist in.
    required: true
  secret-name:
    description: kubernetes secret name to use
    required: true
runs:
  using: composite
  steps:
    - uses: gdcorp-actions/ssl-action@main
      id: certs
      with:
        command: import-secrets
        certificates: '[{"server":"${{ inputs.cert }}","allow_renewal":true}]'
        team: ${{ inputs.group }}
        renew: true
        sso_token: ${{ inputs.jwt }}
        renewal_days: 90
    - shell: bash
      env:
        AWS_REGION: us-west-2
      run: |
        SECRET=$(aws secretsmanager get-secret-value --secret-id '${{ inputs.cert }}' --query 'SecretString' --output text)
        echo ${SECRET} | jq -r .crt > tls.crt
        echo ${SECRET} | jq -r .chain >> tls.crt
        echo ${SECRET} | jq -r .key > tls.key

        for namespace in $(echo ${{ inputs.namespace }} | sed "s/,/ /g")
        do
          kubectl --context=${{ inputs.context }} -n $namespace create secret generic ${{ inputs.secret-name }} --from-file=tls.crt=./tls.crt --from-file=tls.key=./tls.key --dry-run -o yaml | kubectl --context=${{ inputs.context }} -n $namespace apply -f -
        done
        rm tls.crt
        rm tls.key
